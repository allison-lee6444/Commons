from __future__ import print_function

import datetime
import os
import time

from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.by import By

from . import settings, variables


def tail(filename, n):
    """Keep last n lines of file specified by :filename.

    :param filename: <str> Filename to apply tail on
    :param n: <int> Number of lines to keep

    """
    lines = []
    with open(filename, "r") as file:
        lines = file.readlines()

    with open(filename, "w") as file:
        file.writelines(lines[-n:])


def log(msg, reason="INFO"):
    """If settings.logfile is set write :msg in logfile else
    write in standard output.

    :param msg: The message that will be logged - printed
    :param reason: Reason can be one of ["INFO", "DEBUG", "ERROR"]
                   :core_logging setting should be true for displaying "INFO"
                   :debug_logging setting should be true for "INFO", DEBUG" and "ERROR"
    """
    if settings.log_level not in ["", "INFO", "DEBUG", "ERROR"]:
        print("Warning: log_level invalid (falling back to 'INFO'). Use one of ['INFO', 'DEBUG', '']")
        settings.log_level = "INFO"
    if not settings.log_level:
        return
    if settings.log_level == "INFO" and reason == "DEBUG":
        return

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = "[%s] %s: %s" % (reason, timestamp, msg)

    if settings.logfile and os.path.exists(settings.logfile):
        tail(settings.logfile, settings.logfile_rows_keep)

    if settings.logfile:
        open_type = 'w'
        if os.path.exists(settings.logfile):
            open_type = 'a'
        print(log_entry, file=open(settings.logfile, open_type))
    else:
        print(log_entry)


def wait_for_elem(web_driver, elem_val, elem_type="id", max_retries=None):
    """web driver helper utility used to wait until the page is fully
    loaded.

    Tries to find the element specified by :elem_val
    where :elem_val can be of :elem_type 'id', 'class' or 'css'.

    Returns True if element was found in time else False

    After :settings.max_retries number of times stops trying.

    :param elem_val: param web_driver:
    :param elem_type: Default value = "id")
    :param web_driver:
    :param max_retries: number of times to try to find the elem (overrides settings.max_retries)

    """
    if max_retries is None:
        max_retries = settings.max_retries

    retries = 0

    while True:
        try:
            if retries > max_retries:
                return False

            if elem_type == "id":
                web_driver.find_element(By.ID, elem_val)
            elif elem_type == "class":
                web_driver.find_element(By.CLASS_NAME, elem_val)
            elif elem_type == "css":
                web_driver.find_element(By.CSS_SELECTOR, elem_val)
            else:
                raise ValueError("Unknown elem_type")

            time.sleep(0.2)  # add a little extra delay for all elements to load
            return True

        except NoSuchElementException:
            log("(%d/%d)  waiting for %s:%s..." % (retries, settings.max_retries, elem_type, elem_val), "DEBUG")
            retries += 1
            time.sleep(settings.load_wait)


def write_hash(new_hash):
    """Stores the given hash on protonmail work directory

    :param new_hash: a string generated by current inbox mails
    """
    if not os.path.exists(settings.work_directory):
        os.makedirs(settings.work_directory)

    hash_file_path = settings.work_directory + variables.mail_hash_filename
    with open(hash_file_path, "w") as f:
        f.write(new_hash)


def get_hash():
    """Reads and returns the last stored hash

    :return: str
    """
    hash_file_path = settings.work_directory + variables.mail_hash_filename
    if os.path.exists(hash_file_path):
        with open(hash_file_path, "r") as f:
            return f.readline()
    return None


def validate():
    """Asks users type yes or no in order to validate his input

    :return: bool
    """

    return input("Are you sure? [Y/n]").lower() not in {"n", "no", "not"}
