/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/main.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/dist/main.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * React Router v6.16.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n/* eslint-env node */\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./umd/react-router.development.js */ \"(ssr)/./node_modules/react-router/dist/umd/react-router.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViOztBQUVBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBNkQ7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tb25zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L21haW4uanM/MzE4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlYWN0IFJvdXRlciB2Ni4xNi4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91bWQvcmVhY3Qtcm91dGVyLnByb2R1Y3Rpb24ubWluLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91bWQvcmVhY3Qtcm91dGVyLmRldmVsb3BtZW50LmpzXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/main.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/umd/react-router.development.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-router/dist/umd/react-router.development.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * React Router v6.16.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.cjs.js\")) :\n  0;\n})(this, (function (exports, React, router) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n\n  // Create react-specific types from the agnostic types in @remix-run/router to\n  // export from react-router\n  const DataRouterContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    DataRouterContext.displayName = \"DataRouter\";\n  }\n  const DataRouterStateContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n  }\n  const AwaitContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    AwaitContext.displayName = \"Await\";\n  }\n\n  /**\n   * A Navigator is a \"location changer\"; it's how you get to different locations.\n   *\n   * Every history instance conforms to the Navigator interface, but the\n   * distinction is useful primarily when it comes to the low-level <Router> API\n   * where both the location and a navigator must be provided separately in order\n   * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n   * and/or location were to be read directly from the history instance.\n   */\n\n  const NavigationContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    NavigationContext.displayName = \"Navigation\";\n  }\n  const LocationContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    LocationContext.displayName = \"Location\";\n  }\n  const RouteContext = /*#__PURE__*/React__namespace.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n  });\n  {\n    RouteContext.displayName = \"Route\";\n  }\n  const RouteErrorContext = /*#__PURE__*/React__namespace.createContext(null);\n  {\n    RouteErrorContext.displayName = \"RouteError\";\n  }\n\n  /**\n   * Returns the full href for the given \"to\" value. This is useful for building\n   * custom links that are also accessible and preserve right-click behavior.\n   *\n   * @see https://reactrouter.com/hooks/use-href\n   */\n  function useHref(to, _temp) {\n    let {\n      relative\n    } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      basename,\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      hash,\n      pathname,\n      search\n    } = useResolvedPath(to, {\n      relative\n    });\n    let joinedPathname = pathname;\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n      joinedPathname = pathname === \"/\" ? basename : router.joinPaths([basename, pathname]);\n    }\n    return navigator.createHref({\n      pathname: joinedPathname,\n      search,\n      hash\n    });\n  }\n\n  /**\n   * Returns true if this component is a descendant of a <Router>.\n   *\n   * @see https://reactrouter.com/hooks/use-in-router-context\n   */\n  function useInRouterContext() {\n    return React__namespace.useContext(LocationContext) != null;\n  }\n\n  /**\n   * Returns the current location object, which represents the current URL in web\n   * browsers.\n   *\n   * Note: If you're using this it may mean you're doing some of your own\n   * \"routing\" in your app, and we'd like to know what your use case is. We may\n   * be able to provide something higher-level to better suit your needs.\n   *\n   * @see https://reactrouter.com/hooks/use-location\n   */\n  function useLocation() {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\")  : void 0;\n    return React__namespace.useContext(LocationContext).location;\n  }\n\n  /**\n   * Returns the current navigation action which describes how the router came to\n   * the current location, either by a pop, push, or replace on the history stack.\n   *\n   * @see https://reactrouter.com/hooks/use-navigation-type\n   */\n  function useNavigationType() {\n    return React__namespace.useContext(LocationContext).navigationType;\n  }\n\n  /**\n   * Returns a PathMatch object if the given pattern matches the current URL.\n   * This is useful for components that need to know \"active\" state, e.g.\n   * <NavLink>.\n   *\n   * @see https://reactrouter.com/hooks/use-match\n   */\n  function useMatch(pattern) {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      pathname\n    } = useLocation();\n    return React__namespace.useMemo(() => router.matchPath(pattern, pathname), [pathname, pattern]);\n  }\n\n  /**\n   * The interface for the navigate() function returned from useNavigate().\n   */\n\n  const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n  // Mute warnings for calls to useNavigate in SSR environments\n  function useIsomorphicLayoutEffect(cb) {\n    let isStatic = React__namespace.useContext(NavigationContext).static;\n    if (!isStatic) {\n      // We should be able to get rid of this once react 18.3 is released\n      // See: https://github.com/facebook/react/pull/26395\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(cb);\n    }\n  }\n\n  /**\n   * Returns an imperative method for changing the location. Used by <Link>s, but\n   * may also be used by other elements to change the location.\n   *\n   * @see https://reactrouter.com/hooks/use-navigate\n   */\n  function useNavigate() {\n    let {\n      isDataRoute\n    } = React__namespace.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n  }\n  function useNavigateUnstable() {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\")  : void 0;\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\n    let {\n      basename,\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\n    let activeRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(() => {\n      activeRef.current = true;\n    });\n    let navigate = React__namespace.useCallback(function (to, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our history listener yet\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n      let path = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n      // If we're operating within a basename, prepend it to the pathname prior\n      // to handing off to history (but only if we're not in a data router,\n      // otherwise it'll prepend the basename inside of the router).\n      // If this is a root navigation, then we navigate to the raw basename\n      // which allows the basename to have full control over the presence of a\n      // trailing slash on root links\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : router.joinPaths([basename, path.pathname]);\n      }\n      (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n    return navigate;\n  }\n  const OutletContext = /*#__PURE__*/React__namespace.createContext(null);\n\n  /**\n   * Returns the context (if provided) for the child route at this level of the route\n   * hierarchy.\n   * @see https://reactrouter.com/hooks/use-outlet-context\n   */\n  function useOutletContext() {\n    return React__namespace.useContext(OutletContext);\n  }\n\n  /**\n   * Returns the element for the child route at this level of the route\n   * hierarchy. Used internally by <Outlet> to render child routes.\n   *\n   * @see https://reactrouter.com/hooks/use-outlet\n   */\n  function useOutlet(context) {\n    let outlet = React__namespace.useContext(RouteContext).outlet;\n    if (outlet) {\n      return /*#__PURE__*/React__namespace.createElement(OutletContext.Provider, {\n        value: context\n      }, outlet);\n    }\n    return outlet;\n  }\n\n  /**\n   * Returns an object of key/value pairs of the dynamic params from the current\n   * URL that were matched by the route path.\n   *\n   * @see https://reactrouter.com/hooks/use-params\n   */\n  function useParams() {\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n  }\n\n  /**\n   * Resolves the pathname of the given `to` value against the current location.\n   *\n   * @see https://reactrouter.com/hooks/use-resolved-path\n   */\n  function useResolvedPath(to, _temp2) {\n    let {\n      relative\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let routePathnamesJson = JSON.stringify(router.UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\n    return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n  }\n\n  /**\n   * Returns the element of the route that matched the current location, prepared\n   * with the correct context to render the remainder of the route tree. Route\n   * elements in the tree must render an <Outlet> to render their child route's\n   * element.\n   *\n   * @see https://reactrouter.com/hooks/use-routes\n   */\n  function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n  }\n\n  // Internal implementation with accept optional param for RouterProvider usage\n  function useRoutesImpl(routes, locationArg, dataRouterState) {\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\")  : void 0;\n    let {\n      navigator\n    } = React__namespace.useContext(NavigationContext);\n    let {\n      matches: parentMatches\n    } = React__namespace.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    {\n      // You won't get a warning about 2 different <Routes> under a <Route>\n      // without a trailing *, but this is a best-effort warning anyway since we\n      // cannot even give the warning unless they land at the parent route.\n      //\n      // Example:\n      //\n      // <Routes>\n      //   {/* This route path MUST end with /* because otherwise\n      //       it will never match /blog/post/123 */}\n      //   <Route path=\"blog\" element={<Blog />} />\n      //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n      // </Routes>\n      //\n      // function Blog() {\n      //   return (\n      //     <Routes>\n      //       <Route path=\"post/:id\" element={<Post />} />\n      //     </Routes>\n      //   );\n      // }\n      let parentPath = parentRoute && parentRoute.path || \"\";\n      warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n      var _parsedLocationArg$pa;\n      let parsedLocationArg = typeof locationArg === \"string\" ? router.parsePath(locationArg) : locationArg;\n      !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? router.UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\"))  : void 0;\n      location = parsedLocationArg;\n    } else {\n      location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = router.matchRoutes(routes, {\n      pathname: remainingPathname\n    });\n    {\n      router.UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") ;\n      router.UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") ;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n      params: Object.assign({}, parentParams, match.params),\n      pathname: router.joinPaths([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n      pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : router.joinPaths([parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n    })), parentMatches, dataRouterState);\n\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n      return /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\n        value: {\n          location: _extends({\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\"\n          }, location),\n          navigationType: router.Action.Pop\n        }\n      }, renderedMatches);\n    }\n    return renderedMatches;\n  }\n  function DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = router.isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n      padding: \"0.5rem\",\n      backgroundColor: lightgrey\n    };\n    let codeStyles = {\n      padding: \"2px 4px\",\n      backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    {\n      console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n      devInfo = /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React__namespace.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React__namespace.createElement(\"code\", {\n        style: codeStyles\n      }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React__namespace.createElement(\"code\", {\n        style: codeStyles\n      }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React__namespace.createElement(\"h3\", {\n      style: {\n        fontStyle: \"italic\"\n      }\n    }, message), stack ? /*#__PURE__*/React__namespace.createElement(\"pre\", {\n      style: preStyles\n    }, stack) : null, devInfo);\n  }\n  const defaultErrorElement = /*#__PURE__*/React__namespace.createElement(DefaultErrorComponent, null);\n  class RenderErrorBoundary extends React__namespace.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        location: props.location,\n        revalidation: props.revalidation,\n        error: props.error\n      };\n    }\n    static getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n    static getDerivedStateFromProps(props, state) {\n      // When we get into an error state, the user will likely click \"back\" to the\n      // previous page that didn't have an error. Because this wraps the entire\n      // application, that will have no effect--the error page continues to display.\n      // This gives us a mechanism to recover from the error when the location changes.\n      //\n      // Whether we're in an error state or not, we update the location in state\n      // so that when we are in an error state, it gets reset when a new location\n      // comes in and the user recovers from the error.\n      if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n        return {\n          error: props.error,\n          location: props.location,\n          revalidation: props.revalidation\n        };\n      }\n\n      // If we're not changing locations, preserve the location but still surface\n      // any new errors that may come through. We retain the existing error, we do\n      // this because the error provided from the app state may be cleared without\n      // the location changing.\n      return {\n        error: props.error || state.error,\n        location: state.location,\n        revalidation: props.revalidation || state.revalidation\n      };\n    }\n    componentDidCatch(error, errorInfo) {\n      console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n      return this.state.error ? /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\n        value: this.props.routeContext\n      }, /*#__PURE__*/React__namespace.createElement(RouteErrorContext.Provider, {\n        value: this.state.error,\n        children: this.props.component\n      })) : this.props.children;\n    }\n  }\n  function RenderedRoute(_ref) {\n    let {\n      routeContext,\n      match,\n      children\n    } = _ref;\n    let dataRouterContext = React__namespace.useContext(DataRouterContext);\n\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/React__namespace.createElement(RouteContext.Provider, {\n      value: routeContext\n    }, children);\n  }\n  function _renderMatches(matches, parentMatches, dataRouterState) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n      parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n      dataRouterState = null;\n    }\n    if (matches == null) {\n      var _dataRouterState;\n      if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n        // Don't bail if we have data router errors so we can render them in the\n        // boundary.  Use the pre-matched (or shimmed) matches\n        matches = dataRouterState.matches;\n      } else {\n        return null;\n      }\n    }\n    let renderedMatches = matches;\n\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n      let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n      !(errorIndex >= 0) ? router.UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\"))  : void 0;\n      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    return renderedMatches.reduceRight((outlet, match, index) => {\n      let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n      // Only data routers handle errors\n      let errorElement = null;\n      if (dataRouterState) {\n        errorElement = match.route.errorElement || defaultErrorElement;\n      }\n      let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n      let getChildren = () => {\n        let children;\n        if (error) {\n          children = errorElement;\n        } else if (match.route.Component) {\n          // Note: This is a de-optimized path since React won't re-use the\n          // ReactElement since it's identity changes with each new\n          // React.createElement call.  We keep this so folks can use\n          // `<Route Component={...}>` in `<Routes>` but generally `Component`\n          // usage is only advised in `RouterProvider` when we can convert it to\n          // `element` ahead of time.\n          children = /*#__PURE__*/React__namespace.createElement(match.route.Component, null);\n        } else if (match.route.element) {\n          children = match.route.element;\n        } else {\n          children = outlet;\n        }\n        return /*#__PURE__*/React__namespace.createElement(RenderedRoute, {\n          match: match,\n          routeContext: {\n            outlet,\n            matches,\n            isDataRoute: dataRouterState != null\n          },\n          children: children\n        });\n      };\n      // Only wrap in an error boundary within data router usages when we have an\n      // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n      // an ancestor ErrorBoundary/errorElement\n      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React__namespace.createElement(RenderErrorBoundary, {\n        location: dataRouterState.location,\n        revalidation: dataRouterState.revalidation,\n        component: errorElement,\n        error: error,\n        children: getChildren(),\n        routeContext: {\n          outlet: null,\n          matches,\n          isDataRoute: true\n        }\n      }) : getChildren();\n    }, null);\n  }\n  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n  }(DataRouterHook || {});\n  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n  }(DataRouterStateHook || {});\n  function getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n  }\n  function useDataRouterContext(hookName) {\n    let ctx = React__namespace.useContext(DataRouterContext);\n    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return ctx;\n  }\n  function useDataRouterState(hookName) {\n    let state = React__namespace.useContext(DataRouterStateContext);\n    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return state;\n  }\n  function useRouteContext(hookName) {\n    let route = React__namespace.useContext(RouteContext);\n    !route ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return route;\n  }\n\n  // Internal version with hookName-aware debugging\n  function useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ? router.UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\")  : void 0;\n    return thisRoute.route.id;\n  }\n\n  /**\n   * Returns the ID for the nearest contextual route\n   */\n  function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n  }\n\n  /**\n   * Returns the current navigation, defaulting to an \"idle\" navigation when\n   * no navigation is in progress\n   */\n  function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n  }\n\n  /**\n   * Returns a revalidate function for manually triggering revalidation, as well\n   * as the current state of any manual revalidations\n   */\n  function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return React__namespace.useMemo(() => ({\n      revalidate: dataRouterContext.router.revalidate,\n      state: state.revalidation\n    }), [dataRouterContext.router.revalidate, state.revalidation]);\n  }\n\n  /**\n   * Returns the active route matches, useful for accessing loaderData for\n   * parent/child routes or the route \"handle\" property\n   */\n  function useMatches() {\n    let {\n      matches,\n      loaderData\n    } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return React__namespace.useMemo(() => matches.map(m => router.UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n  }\n\n  /**\n   * Returns the loader data for the nearest ancestor Route loader\n   */\n  function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n      console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n      return undefined;\n    }\n    return state.loaderData[routeId];\n  }\n\n  /**\n   * Returns the loaderData for the given routeId\n   */\n  function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n  }\n\n  /**\n   * Returns the action data for the nearest ancestor Route action\n   */\n  function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let route = React__namespace.useContext(RouteContext);\n    !route ? router.UNSAFE_invariant(false, \"useActionData must be used inside a RouteContext\")  : void 0;\n    return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n  }\n\n  /**\n   * Returns the nearest ancestor Route error, which could be a loader/action\n   * error or a render error.  This is intended to be called from your\n   * ErrorBoundary/errorElement to display a proper error message.\n   */\n  function useRouteError() {\n    var _state$errors;\n    let error = React__namespace.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error) {\n      return error;\n    }\n\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n  }\n\n  /**\n   * Returns the happy-path data from the nearest ancestor <Await /> value\n   */\n  function useAsyncValue() {\n    let value = React__namespace.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n  }\n\n  /**\n   * Returns the error from the nearest ancestor <Await /> value\n   */\n  function useAsyncError() {\n    let value = React__namespace.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n  }\n  let blockerId = 0;\n\n  /**\n   * Allow the application to block navigations within the SPA and present the\n   * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n   * using half-filled form data.  This does not handle hard-reloads or\n   * cross-origin navigations.\n   */\n  function useBlocker(shouldBlock) {\n    let {\n      router: router$1,\n      basename\n    } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = React__namespace.useState(\"\");\n    let blockerFunction = React__namespace.useCallback(arg => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n\n      // If they provided us a function and we've got an active basename, strip\n      // it from the locations we expose to the user to match the behavior of\n      // useLocation\n      let {\n        currentLocation,\n        nextLocation,\n        historyAction\n      } = arg;\n      return shouldBlock({\n        currentLocation: _extends({}, currentLocation, {\n          pathname: router.stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n        }),\n        nextLocation: _extends({}, nextLocation, {\n          pathname: router.stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n        }),\n        historyAction\n      });\n    }, [basename, shouldBlock]);\n\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    React__namespace.useEffect(() => {\n      let key = String(++blockerId);\n      setBlockerKey(key);\n      return () => router$1.deleteBlocker(key);\n    }, [router$1]);\n\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    React__namespace.useEffect(() => {\n      if (blockerKey !== \"\") {\n        router$1.getBlocker(blockerKey, blockerFunction);\n      }\n    }, [router$1, blockerKey, blockerFunction]);\n\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router.IDLE_BLOCKER;\n  }\n\n  /**\n   * Stable version of useNavigate that is used when we are in the context of\n   * a RouterProvider.\n   */\n  function useNavigateStable() {\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(() => {\n      activeRef.current = true;\n    });\n    let navigate = React__namespace.useCallback(function (to, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      router.UNSAFE_warning(activeRef.current, navigateEffectWarning) ;\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our router subscriber yet\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        router$1.navigate(to);\n      } else {\n        router$1.navigate(to, _extends({\n          fromRouteId: id\n        }, options));\n      }\n    }, [router$1, id]);\n    return navigate;\n  }\n  const alreadyWarned = {};\n  function warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n      alreadyWarned[key] = true;\n      router.UNSAFE_warning(false, message) ;\n    }\n  }\n\n  /**\n    Webpack + React 17 fails to compile on any of the following because webpack\n    complains that `startTransition` doesn't exist in `React`:\n    * import { startTransition } from \"react\"\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n    Moving it to a constant such as the following solves the Webpack/React 17 issue:\n    * import * as React from from \"react\";\n      const START_TRANSITION = \"startTransition\";\n      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n    However, that introduces webpack/terser minification issues in production builds\n    in React 18 where minification/obfuscation ends up removing the call of\n    React.startTransition entirely from the first half of the ternary.  Grabbing\n    this exported reference once up front resolves that issue.\n\n    See https://github.com/remix-run/react-router/issues/10579\n  */\n  const START_TRANSITION = \"startTransition\";\n  const startTransitionImpl = React__namespace[START_TRANSITION];\n\n  /**\n   * Given a Remix Router instance, render the appropriate UI\n   */\n  function RouterProvider(_ref) {\n    let {\n      fallbackElement,\n      router,\n      future\n    } = _ref;\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    let [state, setStateImpl] = React__namespace.useState(router.state);\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n    let navigator = React__namespace.useMemo(() => {\n      return {\n        createHref: router.createHref,\n        encodeLocation: router.encodeLocation,\n        go: n => router.navigate(n),\n        push: (to, state, opts) => router.navigate(to, {\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        }),\n        replace: (to, state, opts) => router.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        })\n      };\n    }, [router]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = React__namespace.useMemo(() => ({\n      router,\n      navigator,\n      static: false,\n      basename\n    }), [router, navigator, basename]);\n\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(DataRouterContext.Provider, {\n      value: dataRouterContext\n    }, /*#__PURE__*/React__namespace.createElement(DataRouterStateContext.Provider, {\n      value: state\n    }, /*#__PURE__*/React__namespace.createElement(Router, {\n      basename: basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: navigator\n    }, state.initialized ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {\n      routes: router.routes,\n      state: state\n    }) : fallbackElement))), null);\n  }\n  function DataRoutes(_ref2) {\n    let {\n      routes,\n      state\n    } = _ref2;\n    return useRoutesImpl(routes, undefined, state);\n  }\n  /**\n   * A <Router> that stores all entries in memory.\n   *\n   * @see https://reactrouter.com/router-components/memory-router\n   */\n  function MemoryRouter(_ref3) {\n    let {\n      basename,\n      children,\n      initialEntries,\n      initialIndex,\n      future\n    } = _ref3;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createMemoryHistory({\n        initialEntries,\n        initialIndex,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    });\n  }\n  /**\n   * Changes the current location.\n   *\n   * Note: This API is mostly useful in React.Component subclasses that are not\n   * able to use hooks. In functional components, we recommend you use the\n   * `useNavigate` hook instead.\n   *\n   * @see https://reactrouter.com/components/navigate\n   */\n  function Navigate(_ref4) {\n    let {\n      to,\n      replace,\n      state,\n      relative\n    } = _ref4;\n    !useInRouterContext() ? router.UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\")  : void 0;\n    router.UNSAFE_warning(!React__namespace.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") ;\n    let {\n      matches\n    } = React__namespace.useContext(RouteContext);\n    let {\n      pathname: locationPathname\n    } = useLocation();\n    let navigate = useNavigate();\n\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = router.resolveTo(to, router.UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {\n      replace,\n      state,\n      relative\n    }), [navigate, jsonPath, relative, replace, state]);\n    return null;\n  }\n  /**\n   * Renders the child route's element, if there is one.\n   *\n   * @see https://reactrouter.com/components/outlet\n   */\n  function Outlet(props) {\n    return useOutlet(props.context);\n  }\n  /**\n   * Declares an element that should be rendered at a certain URL path.\n   *\n   * @see https://reactrouter.com/components/route\n   */\n  function Route(_props) {\n    router.UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\")  ;\n  }\n  /**\n   * Provides location context for the rest of the app.\n   *\n   * Note: You usually won't render a <Router> directly. Instead, you'll render a\n   * router that is more specific to your environment such as a <BrowserRouter>\n   * in web browsers or a <StaticRouter> for server rendering.\n   *\n   * @see https://reactrouter.com/router-components/router\n   */\n  function Router(_ref5) {\n    let {\n      basename: basenameProp = \"/\",\n      children = null,\n      location: locationProp,\n      navigationType = router.Action.Pop,\n      navigator,\n      static: staticProp = false\n    } = _ref5;\n    !!useInRouterContext() ? router.UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\")  : void 0;\n\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = React__namespace.useMemo(() => ({\n      basename,\n      navigator,\n      static: staticProp\n    }), [basename, navigator, staticProp]);\n    if (typeof locationProp === \"string\") {\n      locationProp = router.parsePath(locationProp);\n    }\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n      state = null,\n      key = \"default\"\n    } = locationProp;\n    let locationContext = React__namespace.useMemo(() => {\n      let trailingPathname = router.stripBasename(pathname, basename);\n      if (trailingPathname == null) {\n        return null;\n      }\n      return {\n        location: {\n          pathname: trailingPathname,\n          search,\n          hash,\n          state,\n          key\n        },\n        navigationType\n      };\n    }, [basename, pathname, search, hash, state, key, navigationType]);\n    router.UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") ;\n    if (locationContext == null) {\n      return null;\n    }\n    return /*#__PURE__*/React__namespace.createElement(NavigationContext.Provider, {\n      value: navigationContext\n    }, /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {\n      children: children,\n      value: locationContext\n    }));\n  }\n  /**\n   * A container for a nested tree of <Route> elements that renders the branch\n   * that best matches the current location.\n   *\n   * @see https://reactrouter.com/components/routes\n   */\n  function Routes(_ref6) {\n    let {\n      children,\n      location\n    } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n  }\n  /**\n   * Component to use for rendering lazily loaded data from returning defer()\n   * in a loader function\n   */\n  function Await(_ref7) {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = _ref7;\n    return /*#__PURE__*/React__namespace.createElement(AwaitErrorBoundary, {\n      resolve: resolve,\n      errorElement: errorElement\n    }, /*#__PURE__*/React__namespace.createElement(ResolveAwait, null, children));\n  }\n  var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n  }(AwaitRenderStatus || {});\n  const neverSettledPromise = new Promise(() => {});\n  class AwaitErrorBoundary extends React__namespace.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        error: null\n      };\n    }\n    static getDerivedStateFromError(error) {\n      return {\n        error\n      };\n    }\n    componentDidCatch(error, errorInfo) {\n      console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n      let {\n        children,\n        errorElement,\n        resolve\n      } = this.props;\n      let promise = null;\n      let status = AwaitRenderStatus.pending;\n      if (!(resolve instanceof Promise)) {\n        // Didn't get a promise - provide as a resolved promise\n        status = AwaitRenderStatus.success;\n        promise = Promise.resolve();\n        Object.defineProperty(promise, \"_tracked\", {\n          get: () => true\n        });\n        Object.defineProperty(promise, \"_data\", {\n          get: () => resolve\n        });\n      } else if (this.state.error) {\n        // Caught a render error, provide it as a rejected promise\n        status = AwaitRenderStatus.error;\n        let renderError = this.state.error;\n        promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n        Object.defineProperty(promise, \"_tracked\", {\n          get: () => true\n        });\n        Object.defineProperty(promise, \"_error\", {\n          get: () => renderError\n        });\n      } else if (resolve._tracked) {\n        // Already tracked promise - check contents\n        promise = resolve;\n        status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n      } else {\n        // Raw (untracked) promise - track it\n        status = AwaitRenderStatus.pending;\n        Object.defineProperty(resolve, \"_tracked\", {\n          get: () => true\n        });\n        promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n          get: () => data\n        }), error => Object.defineProperty(resolve, \"_error\", {\n          get: () => error\n        }));\n      }\n      if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError) {\n        // Freeze the UI by throwing a never resolved promise\n        throw neverSettledPromise;\n      }\n      if (status === AwaitRenderStatus.error && !errorElement) {\n        // No errorElement, throw to the nearest route-level error boundary\n        throw promise._error;\n      }\n      if (status === AwaitRenderStatus.error) {\n        // Render via our errorElement\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: errorElement\n        });\n      }\n      if (status === AwaitRenderStatus.success) {\n        // Render children with resolved value\n        return /*#__PURE__*/React__namespace.createElement(AwaitContext.Provider, {\n          value: promise,\n          children: children\n        });\n      }\n\n      // Throw to the suspense boundary\n      throw promise;\n    }\n  }\n\n  /**\n   * @private\n   * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n   */\n  function ResolveAwait(_ref8) {\n    let {\n      children\n    } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, toRender);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // UTILS\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Creates a route config from a React \"children\" object, which is usually\n   * either a `<Route>` element or an array of them. Used internally by\n   * `<Routes>` to create a route config from its children.\n   *\n   * @see https://reactrouter.com/utils/create-routes-from-children\n   */\n  function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n      parentPath = [];\n    }\n    let routes = [];\n    React__namespace.Children.forEach(children, (element, index) => {\n      if (! /*#__PURE__*/React__namespace.isValidElement(element)) {\n        // Ignore non-elements. This allows people to more easily inline\n        // conditionals in their route config.\n        return;\n      }\n      let treePath = [...parentPath, index];\n      if (element.type === React__namespace.Fragment) {\n        // Transparently support React.Fragment and its children.\n        routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n        return;\n      }\n      !(element.type === Route) ? router.UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\")  : void 0;\n      !(!element.props.index || !element.props.children) ? router.UNSAFE_invariant(false, \"An index route cannot have child routes.\")  : void 0;\n      let route = {\n        id: element.props.id || treePath.join(\"-\"),\n        caseSensitive: element.props.caseSensitive,\n        element: element.props.element,\n        Component: element.props.Component,\n        index: element.props.index,\n        path: element.props.path,\n        loader: element.props.loader,\n        action: element.props.action,\n        errorElement: element.props.errorElement,\n        ErrorBoundary: element.props.ErrorBoundary,\n        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n        shouldRevalidate: element.props.shouldRevalidate,\n        handle: element.props.handle,\n        lazy: element.props.lazy\n      };\n      if (element.props.children) {\n        route.children = createRoutesFromChildren(element.props.children, treePath);\n      }\n      routes.push(route);\n    });\n    return routes;\n  }\n\n  /**\n   * Renders the result of `matchRoutes()` into a React element.\n   */\n  function renderMatches(matches) {\n    return _renderMatches(matches);\n  }\n\n  function mapRouteProperties(route) {\n    let updates = {\n      // Note: this check also occurs in createRoutesFromChildren so update\n      // there if you change this -- please and thank you!\n      hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n      {\n        if (route.element) {\n          router.UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        element: /*#__PURE__*/React__namespace.createElement(route.Component),\n        Component: undefined\n      });\n    }\n    if (route.ErrorBoundary) {\n      {\n        if (route.errorElement) {\n          router.UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") ;\n        }\n      }\n      Object.assign(updates, {\n        errorElement: /*#__PURE__*/React__namespace.createElement(route.ErrorBoundary),\n        ErrorBoundary: undefined\n      });\n    }\n    return updates;\n  }\n  function createMemoryRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createMemoryHistory({\n        initialEntries: opts == null ? void 0 : opts.initialEntries,\n        initialIndex: opts == null ? void 0 : opts.initialIndex\n      }),\n      hydrationData: opts == null ? void 0 : opts.hydrationData,\n      routes,\n      mapRouteProperties\n    }).initialize();\n  }\n\n  Object.defineProperty(exports, 'AbortedDeferredError', {\n    enumerable: true,\n    get: function () { return router.AbortedDeferredError; }\n  });\n  Object.defineProperty(exports, 'NavigationType', {\n    enumerable: true,\n    get: function () { return router.Action; }\n  });\n  Object.defineProperty(exports, 'createPath', {\n    enumerable: true,\n    get: function () { return router.createPath; }\n  });\n  Object.defineProperty(exports, 'defer', {\n    enumerable: true,\n    get: function () { return router.defer; }\n  });\n  Object.defineProperty(exports, 'generatePath', {\n    enumerable: true,\n    get: function () { return router.generatePath; }\n  });\n  Object.defineProperty(exports, 'isRouteErrorResponse', {\n    enumerable: true,\n    get: function () { return router.isRouteErrorResponse; }\n  });\n  Object.defineProperty(exports, 'json', {\n    enumerable: true,\n    get: function () { return router.json; }\n  });\n  Object.defineProperty(exports, 'matchPath', {\n    enumerable: true,\n    get: function () { return router.matchPath; }\n  });\n  Object.defineProperty(exports, 'matchRoutes', {\n    enumerable: true,\n    get: function () { return router.matchRoutes; }\n  });\n  Object.defineProperty(exports, 'parsePath', {\n    enumerable: true,\n    get: function () { return router.parsePath; }\n  });\n  Object.defineProperty(exports, 'redirect', {\n    enumerable: true,\n    get: function () { return router.redirect; }\n  });\n  Object.defineProperty(exports, 'redirectDocument', {\n    enumerable: true,\n    get: function () { return router.redirectDocument; }\n  });\n  Object.defineProperty(exports, 'resolvePath', {\n    enumerable: true,\n    get: function () { return router.resolvePath; }\n  });\n  exports.Await = Await;\n  exports.MemoryRouter = MemoryRouter;\n  exports.Navigate = Navigate;\n  exports.Outlet = Outlet;\n  exports.Route = Route;\n  exports.Router = Router;\n  exports.RouterProvider = RouterProvider;\n  exports.Routes = Routes;\n  exports.UNSAFE_DataRouterContext = DataRouterContext;\n  exports.UNSAFE_DataRouterStateContext = DataRouterStateContext;\n  exports.UNSAFE_LocationContext = LocationContext;\n  exports.UNSAFE_NavigationContext = NavigationContext;\n  exports.UNSAFE_RouteContext = RouteContext;\n  exports.UNSAFE_mapRouteProperties = mapRouteProperties;\n  exports.UNSAFE_useRouteId = useRouteId;\n  exports.UNSAFE_useRoutesImpl = useRoutesImpl;\n  exports.createMemoryRouter = createMemoryRouter;\n  exports.createRoutesFromChildren = createRoutesFromChildren;\n  exports.createRoutesFromElements = createRoutesFromChildren;\n  exports.renderMatches = renderMatches;\n  exports.unstable_useBlocker = useBlocker;\n  exports.useActionData = useActionData;\n  exports.useAsyncError = useAsyncError;\n  exports.useAsyncValue = useAsyncValue;\n  exports.useHref = useHref;\n  exports.useInRouterContext = useInRouterContext;\n  exports.useLoaderData = useLoaderData;\n  exports.useLocation = useLocation;\n  exports.useMatch = useMatch;\n  exports.useMatches = useMatches;\n  exports.useNavigate = useNavigate;\n  exports.useNavigation = useNavigation;\n  exports.useNavigationType = useNavigationType;\n  exports.useOutlet = useOutlet;\n  exports.useOutletContext = useOutletContext;\n  exports.useParams = useParams;\n  exports.useResolvedPath = useResolvedPath;\n  exports.useRevalidator = useRevalidator;\n  exports.useRouteError = useRouteError;\n  exports.useRouteLoaderData = useRouteLoaderData;\n  exports.useRoutes = useRoutes;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-router.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvdW1kL3JlYWN0LXJvdXRlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBTyxHQUFHLG1CQUFPLENBQUMsb0ZBQW1CO0FBQy9ILEVBQUUsQ0FDOEk7QUFDaEosQ0FBQyw2Q0FBNkM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUF3QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRCw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHFCQUFxQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBCQUEwQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0JBQXdCO0FBQzNCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW1vbnMvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvdW1kL3JlYWN0LXJvdXRlci5kZXZlbG9wbWVudC5qcz9lZGZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIHY2LjE2LjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpLCByZXF1aXJlKCdAcmVtaXgtcnVuL3JvdXRlcicpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnLCAnQHJlbWl4LXJ1bi9yb3V0ZXInXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdFJvdXRlciA9IHt9LCBnbG9iYWwuUmVhY3QsIGdsb2JhbC5SZW1peFJvdXRlcikpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBSZWFjdCwgcm91dGVyKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHJlYWN0LXNwZWNpZmljIHR5cGVzIGZyb20gdGhlIGFnbm9zdGljIHR5cGVzIGluIEByZW1peC1ydW4vcm91dGVyIHRvXG4gIC8vIGV4cG9ydCBmcm9tIHJlYWN0LXJvdXRlclxuICBjb25zdCBEYXRhUm91dGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQobnVsbCk7XG4gIHtcbiAgICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xuICB9XG4gIGNvbnN0IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG51bGwpO1xuICB7XG4gICAgRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG4gIH1cbiAgY29uc3QgQXdhaXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dChudWxsKTtcbiAge1xuICAgIEF3YWl0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXdhaXRcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gICAqXG4gICAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAgICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgPFJvdXRlcj4gQVBJXG4gICAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcbiAgICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXG4gICAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAgICovXG5cbiAgY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG51bGwpO1xuICB7XG4gICAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbiAgfVxuICBjb25zdCBMb2NhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG51bGwpO1xuICB7XG4gICAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xuICB9XG4gIGNvbnN0IFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQoe1xuICAgIG91dGxldDogbnVsbCxcbiAgICBtYXRjaGVzOiBbXSxcbiAgICBpc0RhdGFSb3V0ZTogZmFsc2VcbiAgfSk7XG4gIHtcbiAgICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG4gIH1cbiAgY29uc3QgUm91dGVFcnJvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG51bGwpO1xuICB7XG4gICAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICAgKiBjdXN0b20gbGlua3MgdGhhdCBhcmUgYWxzbyBhY2Nlc3NpYmxlIGFuZCBwcmVzZXJ2ZSByaWdodC1jbGljayBiZWhhdmlvci5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICAgKi9cbiAgZnVuY3Rpb24gdXNlSHJlZih0bywgX3RlbXApIHtcbiAgICBsZXQge1xuICAgICAgcmVsYXRpdmVcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBcInVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSAgOiB2b2lkIDA7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IHtcbiAgICAgIGhhc2gsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaFxuICAgIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSk7XG4gICAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgLy8gdG8gY3JlYXRpbmcgdGhlIGhyZWYuICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlIHRoZSByYXdcbiAgICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gICAgLy8gb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gICAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IHJvdXRlci5qb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoe1xuICAgICAgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGVyPi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBVUkwgaW4gd2ViXG4gICAqIGJyb3dzZXJzLlxuICAgKlxuICAgKiBOb3RlOiBJZiB5b3UncmUgdXNpbmcgdGhpcyBpdCBtYXkgbWVhbiB5b3UncmUgZG9pbmcgc29tZSBvZiB5b3VyIG93blxuICAgKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gICAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWxvY2F0aW9uXG4gICAqL1xuICBmdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAgICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gICAqL1xuICBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFBhdGhNYXRjaCBvYmplY3QgaWYgdGhlIGdpdmVuIHBhdHRlcm4gbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAgICogPE5hdkxpbms+LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1tYXRjaFxuICAgKi9cbiAgZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgXCJ1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpICA6IHZvaWQgMDtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWVcbiAgICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IHJvdXRlci5tYXRjaFBhdGgocGF0dGVybiwgcGF0aG5hbWUpLCBbcGF0aG5hbWUsIHBhdHRlcm5dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gICAqL1xuXG4gIGNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IFwiWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gXCIgKyBcInlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLlwiO1xuXG4gIC8vIE11dGUgd2FybmluZ3MgZm9yIGNhbGxzIHRvIHVzZU5hdmlnYXRlIGluIFNTUiBlbnZpcm9ubWVudHNcbiAgZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICAgIGxldCBpc1N0YXRpYyA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICAgIGlmICghaXNTdGF0aWMpIHtcbiAgICAgIC8vIFdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgdGhpcyBvbmNlIHJlYWN0IDE4LjMgaXMgcmVsZWFzZWRcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gICAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICAgIGxldCB7XG4gICAgICBpc0RhdGFSb3V0ZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgXCJ1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpICA6IHZvaWQgMDtcbiAgICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvclxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCB7XG4gICAgICBtYXRjaGVzXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICAgIH0gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShyb3V0ZXIuVU5TQUZFX2dldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpLm1hcChtYXRjaCA9PiBtYXRjaC5wYXRobmFtZUJhc2UpKTtcbiAgICBsZXQgYWN0aXZlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoZmFsc2UpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGxldCBuYXZpZ2F0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA7XG5cbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaGVyZSBzaW5jZSBpZiB0aGlzIGhhcHBlbnMgb24gZmlyc3QgcmVuZGVyIHRoZSBuYXZpZ2F0ZVxuICAgICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIGhpc3RvcnkgbGlzdGVuZXIgeWV0XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRoID0gcm91dGVyLnJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIik7XG5cbiAgICAgIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgICAgIC8vIHRvIGhhbmRpbmcgb2ZmIHRvIGhpc3RvcnkgKGJ1dCBvbmx5IGlmIHdlJ3JlIG5vdCBpbiBhIGRhdGEgcm91dGVyLFxuICAgICAgLy8gb3RoZXJ3aXNlIGl0J2xsIHByZXBlbmQgdGhlIGJhc2VuYW1lIGluc2lkZSBvZiB0aGUgcm91dGVyKS5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4gd2UgbmF2aWdhdGUgdG8gdGhlIHJhdyBiYXNlbmFtZVxuICAgICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhXG4gICAgICAvLyB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gICAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiByb3V0ZXIuam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgICAgfVxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkocGF0aCwgb3B0aW9ucy5zdGF0ZSwgb3B0aW9ucyk7XG4gICAgfSwgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgZGF0YVJvdXRlckNvbnRleHRdKTtcbiAgICByZXR1cm4gbmF2aWdhdGU7XG4gIH1cbiAgY29uc3QgT3V0bGV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRleHQgKGlmIHByb3ZpZGVkKSBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gICAqIGhpZXJhcmNoeS5cbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0LWNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAgICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0XG4gICAqL1xuICBmdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dCkge1xuICAgIGxldCBvdXRsZXQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gICAgaWYgKG91dGxldCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgICAgfSwgb3V0bGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAgICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1wYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgICBsZXQge1xuICAgICAgbWF0Y2hlc1xuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJlc29sdmVkLXBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bywgX3RlbXAyKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgbGV0IHtcbiAgICAgIG1hdGNoZXNcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gICAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHJvdXRlci5VTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSkpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gcm91dGVyLnJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpLCBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gICAqIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dCB0byByZW5kZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgdHJlZS4gUm91dGVcbiAgICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAgICogZWxlbWVudC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utcm91dGVzXG4gICAqL1xuICBmdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xuICAgIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcpO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gd2l0aCBhY2NlcHQgb3B0aW9uYWwgcGFyYW0gZm9yIFJvdXRlclByb3ZpZGVyIHVzYWdlXG4gIGZ1bmN0aW9uIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpICA6IHZvaWQgMDtcbiAgICBsZXQge1xuICAgICAgbmF2aWdhdG9yXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IHtcbiAgICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXNcbiAgICB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gICAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICAgIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gICAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICAgIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcbiAgICB7XG4gICAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBFeGFtcGxlOlxuICAgICAgLy9cbiAgICAgIC8vIDxSb3V0ZXM+XG4gICAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgICAgLy8gPC9Sb3V0ZXM+XG4gICAgICAvL1xuICAgICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAgIC8vICAgcmV0dXJuIChcbiAgICAgIC8vICAgICA8Um91dGVzPlxuICAgICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgICAgLy8gICAgIDwvUm91dGVzPlxuICAgICAgLy8gICApO1xuICAgICAgLy8gfVxuICAgICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoIHx8IFwiXCI7XG4gICAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xuICAgIH1cbiAgICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IGxvY2F0aW9uO1xuICAgIGlmIChsb2NhdGlvbkFyZykge1xuICAgICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcbiAgICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHJvdXRlci5wYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gICAgICAhKHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgKChfcGFyc2VkTG9jYXRpb25BcmckcGEgPSBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJzZWRMb2NhdGlvbkFyZyRwYS5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSkpKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIldoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgYDxSb3V0ZXMgbG9jYXRpb24+YCBvciBgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pYCwgXCIgKyBcInRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBcIiArIChcIm1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXFxcIlwiICsgcGFyZW50UGF0aG5hbWVCYXNlICsgXCJcXFwiIFwiKSArIChcImJ1dCBwYXRobmFtZSBcXFwiXCIgKyBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSArIFwiXFxcIiB3YXMgZ2l2ZW4gaW4gdGhlIGBsb2NhdGlvbmAgcHJvcC5cIikpICA6IHZvaWQgMDtcbiAgICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgICB9XG4gICAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UocGFyZW50UGF0aG5hbWVCYXNlLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoZXMgPSByb3V0ZXIubWF0Y2hSb3V0ZXMocm91dGVzLCB7XG4gICAgICBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWVcbiAgICB9KTtcbiAgICB7XG4gICAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcocGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLCBcIk5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIikgO1xuICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKG1hdGNoZXMgPT0gbnVsbCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5Db21wb25lbnQgIT09IHVuZGVmaW5lZCwgXCJNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiICsgXCJkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIFwiICsgXCJudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFxcXCJlbXB0eVxcXCIgcGFnZS5cIikgO1xuICAgIH1cbiAgICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChtYXRjaCA9PiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICBwYXRobmFtZTogcm91dGVyLmpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZSkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogcm91dGVyLmpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgICB9KSksIHBhcmVudE1hdGNoZXMsIGRhdGFSb3V0ZXJTdGF0ZSk7XG5cbiAgICAvLyBXaGVuIGEgdXNlciBwYXNzZXMgaW4gYSBgbG9jYXRpb25BcmdgLCB0aGUgYXNzb2NpYXRlZCByb3V0ZXMgbmVlZCB0b1xuICAgIC8vIGJlIHdyYXBwZWQgaW4gYSBuZXcgYExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcmAgaW4gb3JkZXIgZm9yIGB1c2VMb2NhdGlvbmBcbiAgICAvLyB0byB1c2UgdGhlIHNjb3BlZCBsb2NhdGlvbiBpbnN0ZWFkIG9mIHRoZSBnbG9iYWwgbG9jYXRpb24uXG4gICAgaWYgKGxvY2F0aW9uQXJnICYmIHJlbmRlcmVkTWF0Y2hlcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbG9jYXRpb246IF9leHRlbmRzKHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGtleTogXCJkZWZhdWx0XCJcbiAgICAgICAgICB9LCBsb2NhdGlvbiksXG4gICAgICAgICAgbmF2aWdhdGlvblR5cGU6IHJvdXRlci5BY3Rpb24uUG9wXG4gICAgICAgIH1cbiAgICAgIH0sIHJlbmRlcmVkTWF0Y2hlcyk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG4gIH1cbiAgZnVuY3Rpb24gRGVmYXVsdEVycm9yQ29tcG9uZW50KCkge1xuICAgIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgICBsZXQgbWVzc2FnZSA9IHJvdXRlci5pc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgKyBcIiBcIiArIGVycm9yLnN0YXR1c1RleHQgOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICAgIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgICBsZXQgcHJlU3R5bGVzID0ge1xuICAgICAgcGFkZGluZzogXCIwLjVyZW1cIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gICAgfTtcbiAgICBsZXQgY29kZVN0eWxlcyA9IHtcbiAgICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXlcbiAgICB9O1xuICAgIGxldCBkZXZJbmZvID0gbnVsbDtcbiAgICB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxlZCBieSBSZWFjdCBSb3V0ZXIgZGVmYXVsdCBFcnJvckJvdW5kYXJ5OlwiLCBlcnJvcik7XG4gICAgICBkZXZJbmZvID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdUQ4M0RcXHVEQ0JGIEhleSBkZXZlbG9wZXIgXFx1RDgzRFxcdURDNEJcIiksIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzIGJ5IHByb3ZpZGluZyB5b3VyIG93biBcIiwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xuICAgICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgICAgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xuICAgICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgICAgfSwgXCJlcnJvckVsZW1lbnRcIiksIFwiIHByb3Agb24geW91ciByb3V0ZS5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImgzXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgfVxuICAgIH0sIG1lc3NhZ2UpLCBzdGFjayA/IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgICAgc3R5bGU6IHByZVN0eWxlc1xuICAgIH0sIHN0YWNrKSA6IG51bGwsIGRldkluZm8pO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KERlZmF1bHRFcnJvckNvbXBvbmVudCwgbnVsbCk7XG4gIGNsYXNzIFJlbmRlckVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdF9fbmFtZXNwYWNlLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgICAvLyBwcmV2aW91cyBwYWdlIHRoYXQgZGlkbid0IGhhdmUgYW4gZXJyb3IuIEJlY2F1c2UgdGhpcyB3cmFwcyB0aGUgZW50aXJlXG4gICAgICAvLyBhcHBsaWNhdGlvbiwgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZSBjb250aW51ZXMgdG8gZGlzcGxheS5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRoZSBlcnJvciB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgICAgLy9cbiAgICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAgIC8vIGNvbWVzIGluIGFuZCB0aGUgdXNlciByZWNvdmVycyBmcm9tIHRoZSBlcnJvci5cbiAgICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY2hhbmdpbmcgbG9jYXRpb25zLCBwcmVzZXJ2ZSB0aGUgbG9jYXRpb24gYnV0IHN0aWxsIHN1cmZhY2VcbiAgICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAgIC8vIHRoZSBsb2NhdGlvbiBjaGFuZ2luZy5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBzdGF0ZS5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHRcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNvbXBvbmVudFxuICAgICAgfSkpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZShfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlQ29udGV4dCxcbiAgICAgIG1hdGNoLFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjtcbiAgICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuXG4gICAgLy8gVHJhY2sgaG93IGRlZXAgd2UgZ290IGluIG91ciByZW5kZXIgcGFzcyB0byBlbXVsYXRlIFNTUiBjb21wb25lbnREaWRDYXRjaFxuICAgIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHJvdXRlQ29udGV4dFxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxuICBmdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUpIHtcbiAgICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTI7XG4gICAgaWYgKHBhcmVudE1hdGNoZXMgPT09IHZvaWQgMCkge1xuICAgICAgcGFyZW50TWF0Y2hlcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGRhdGFSb3V0ZXJTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICAgIHZhciBfZGF0YVJvdXRlclN0YXRlO1xuICAgICAgaWYgKChfZGF0YVJvdXRlclN0YXRlID0gZGF0YVJvdXRlclN0YXRlKSAhPSBudWxsICYmIF9kYXRhUm91dGVyU3RhdGUuZXJyb3JzKSB7XG4gICAgICAgIC8vIERvbid0IGJhaWwgaWYgd2UgaGF2ZSBkYXRhIHJvdXRlciBlcnJvcnMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGluIHRoZVxuICAgICAgICAvLyBib3VuZGFyeS4gIFVzZSB0aGUgcHJlLW1hdGNoZWQgKG9yIHNoaW1tZWQpIG1hdGNoZXNcbiAgICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBkYXRhIGVycm9ycywgdHJpbSBtYXRjaGVzIHRvIHRoZSBoaWdoZXN0IGVycm9yIGJvdW5kYXJ5XG4gICAgbGV0IGVycm9ycyA9IChfZGF0YVJvdXRlclN0YXRlMiA9IGRhdGFSb3V0ZXJTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUm91dGVyU3RhdGUyLmVycm9ycztcbiAgICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICAgIGxldCBlcnJvckluZGV4ID0gcmVuZGVyZWRNYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgJiYgKGVycm9ycyA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JzW20ucm91dGUuaWRdKSk7XG4gICAgICAhKGVycm9ySW5kZXggPj0gMCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciBlcnJvcnMgb24gcm91dGUgSURzOiBcIiArIE9iamVjdC5rZXlzKGVycm9ycykuam9pbihcIixcIikpICA6IHZvaWQgMDtcbiAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGVycm9yID0gbWF0Y2gucm91dGUuaWQgPyBlcnJvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiBudWxsO1xuICAgICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9yc1xuICAgICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XG4gICAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgICAgfVxuICAgICAgbGV0IG1hdGNoZXMgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSBlcnJvckVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIGRlLW9wdGltaXplZCBwYXRoIHNpbmNlIFJlYWN0IHdvbid0IHJlLXVzZSB0aGVcbiAgICAgICAgICAvLyBSZWFjdEVsZW1lbnQgc2luY2UgaXQncyBpZGVudGl0eSBjaGFuZ2VzIHdpdGggZWFjaCBuZXdcbiAgICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxuICAgICAgICAgIC8vIGA8Um91dGUgQ29tcG9uZW50PXsuLi59PmAgaW4gYDxSb3V0ZXM+YCBidXQgZ2VuZXJhbGx5IGBDb21wb25lbnRgXG4gICAgICAgICAgLy8gdXNhZ2UgaXMgb25seSBhZHZpc2VkIGluIGBSb3V0ZXJQcm92aWRlcmAgd2hlbiB3ZSBjYW4gY29udmVydCBpdCB0b1xuICAgICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVuZGVyZWRSb3V0ZSwge1xuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvLyBPbmx5IHdyYXAgaW4gYW4gZXJyb3IgYm91bmRhcnkgd2l0aGluIGRhdGEgcm91dGVyIHVzYWdlcyB3aGVuIHdlIGhhdmUgYW5cbiAgICAgIC8vIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IG9uIHRoaXMgcm91dGUuICBPdGhlcndpc2UgbGV0IGl0IGJ1YmJsZSB1cCB0b1xuICAgICAgLy8gYW4gYW5jZXN0b3IgRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnRcbiAgICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVuZGVyRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICBvdXRsZXQ6IG51bGwsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBpc0RhdGFSb3V0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KSA6IGdldENoaWxkcmVuKCk7XG4gICAgfSwgbnVsbCk7XG4gIH1cbiAgdmFyIERhdGFSb3V0ZXJIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xuICAgIERhdGFSb3V0ZXJIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xuICAgIERhdGFSb3V0ZXJIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgICByZXR1cm4gRGF0YVJvdXRlckhvb2s7XG4gIH0oRGF0YVJvdXRlckhvb2sgfHwge30pO1xuICB2YXIgRGF0YVJvdXRlclN0YXRlSG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUxvYWRlckRhdGFcIl0gPSBcInVzZUxvYWRlckRhdGFcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQWN0aW9uRGF0YVwiXSA9IFwidXNlQWN0aW9uRGF0YVwiO1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUVycm9yXCJdID0gXCJ1c2VSb3V0ZUVycm9yXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRpb25cIl0gPSBcInVzZU5hdmlnYXRpb25cIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVMb2FkZXJEYXRhXCJdID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTWF0Y2hlc1wiXSA9IFwidXNlTWF0Y2hlc1wiO1xuICAgIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlSWRcIl0gPSBcInVzZVJvdXRlSWRcIjtcbiAgICByZXR1cm4gRGF0YVJvdXRlclN0YXRlSG9vaztcbiAgfShEYXRhUm91dGVyU3RhdGVIb29rIHx8IHt9KTtcbiAgZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICAgIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgICBsZXQgY3R4ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgICAhY3R4ID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBmdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgICBsZXQgc3RhdGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgIXN0YXRlID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZSkge1xuICAgIGxldCByb3V0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAgICFyb3V0ZSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgIDogdm9pZCAwO1xuICAgIHJldHVybiByb3V0ZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIHZlcnNpb24gd2l0aCBob29rTmFtZS1hd2FyZSBkZWJ1Z2dpbmdcbiAgZnVuY3Rpb24gdXNlQ3VycmVudFJvdXRlSWQoaG9va05hbWUpIHtcbiAgICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICAgIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgIXRoaXNSb3V0ZS5yb3V0ZS5pZCA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBob29rTmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpICA6IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgbmVhcmVzdCBjb250ZXh0dWFsIHJvdXRlXG4gICAqL1xuICBmdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICAgIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cbiAgICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAgKi9cbiAgZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcbiAgICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmV2YWxpZGF0ZSBmdW5jdGlvbiBmb3IgbWFudWFsbHkgdHJpZ2dlcmluZyByZXZhbGlkYXRpb24sIGFzIHdlbGxcbiAgICogYXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYW55IG1hbnVhbCByZXZhbGlkYXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gICAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxuICAgICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH0pLCBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLCB1c2VmdWwgZm9yIGFjY2Vzc2luZyBsb2FkZXJEYXRhIGZvclxuICAgKiBwYXJlbnQvY2hpbGQgcm91dGVzIG9yIHRoZSByb3V0ZSBcImhhbmRsZVwiIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICAgIGxldCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YVxuICAgIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VNYXRjaGVzKTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG0gPT4gcm91dGVyLlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksIFttYXRjaGVzLCBsb2FkZXJEYXRhXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9hZGVyIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGxvYWRlclxuICAgKi9cbiAgZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gICAgaWYgKHN0YXRlLmVycm9ycyAmJiBzdGF0ZS5lcnJvcnNbcm91dGVJZF0gIT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIllvdSBjYW5ub3QgYHVzZUxvYWRlckRhdGFgIGluIGFuIGVycm9yRWxlbWVudCAocm91dGVJZDogXCIgKyByb3V0ZUlkICsgXCIpXCIpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcbiAgICovXG4gIGZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gICAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcbiAgICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhY3Rpb24gZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgYWN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICAgIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuICAgIGxldCByb3V0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAgICFyb3V0ZSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUFjdGlvbkRhdGEgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5hY3Rpb25EYXRhKSB8fCB7fSlbMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBlcnJvciwgd2hpY2ggY291bGQgYmUgYSBsb2FkZXIvYWN0aW9uXG4gICAqIGVycm9yIG9yIGEgcmVuZGVyIGVycm9yLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSB5b3VyXG4gICAqIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IHRvIGRpc3BsYXkgYSBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gICAgdmFyIF9zdGF0ZSRlcnJvcnM7XG4gICAgbGV0IGVycm9yID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcbiAgICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG5cbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAgIC8vIG9mIFJlbmRlckVycm9yQm91bmRhcnlcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgbG9vayBmb3IgZXJyb3JzIGZyb20gb3VyIGRhdGEgcm91dGVyIHN0YXRlXG4gICAgcmV0dXJuIChfc3RhdGUkZXJyb3JzID0gc3RhdGUuZXJyb3JzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGVycm9yc1tyb3V0ZUlkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoYXBweS1wYXRoIGRhdGEgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciA8QXdhaXQgLz4gdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XG4gICAgbGV0IHZhbHVlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIDxBd2FpdCAvPiB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgICBsZXQgdmFsdWUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9lcnJvcjtcbiAgfVxuICBsZXQgYmxvY2tlcklkID0gMDtcblxuICAvKipcbiAgICogQWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGJsb2NrIG5hdmlnYXRpb25zIHdpdGhpbiB0aGUgU1BBIGFuZCBwcmVzZW50IHRoZVxuICAgKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAgICogdXNpbmcgaGFsZi1maWxsZWQgZm9ybSBkYXRhLiAgVGhpcyBkb2VzIG5vdCBoYW5kbGUgaGFyZC1yZWxvYWRzIG9yXG4gICAqIGNyb3NzLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVyOiByb3V0ZXIkMSxcbiAgICAgIGJhc2VuYW1lXG4gICAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUJsb2NrZXIpO1xuICAgIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUJsb2NrZXIpO1xuICAgIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFwiXCIpO1xuICAgIGxldCBibG9ja2VyRnVuY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGFyZyA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGV5IHByb3ZpZGVkIHVzIGEgZnVuY3Rpb24gYW5kIHdlJ3ZlIGdvdCBhbiBhY3RpdmUgYmFzZW5hbWUsIHN0cmlwXG4gICAgICAvLyBpdCBmcm9tIHRoZSBsb2NhdGlvbnMgd2UgZXhwb3NlIHRvIHRoZSB1c2VyIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZlxuICAgICAgLy8gdXNlTG9jYXRpb25cbiAgICAgIGxldCB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9ID0gYXJnO1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7XG4gICAgICAgICAgcGF0aG5hbWU6IHJvdXRlci5zdHJpcEJhc2VuYW1lKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9KSxcbiAgICAgICAgbmV4dExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgbmV4dExvY2F0aW9uLCB7XG4gICAgICAgICAgcGF0aG5hbWU6IHJvdXRlci5zdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9KSxcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgfSwgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja10pO1xuXG4gICAgLy8gVGhpcyBlZmZlY3QgaXMgaW4gY2hhcmdlIG9mIGJsb2NrZXIga2V5IGFzc2lnbm1lbnQgYW5kIGRlbGV0aW9uICh3aGljaCBpc1xuICAgIC8vIHRpZ2h0bHkgY291cGxlZCB0byB0aGUga2V5KVxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgICAgc2V0QmxvY2tlcktleShrZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHJvdXRlciQxLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgICB9LCBbcm91dGVyJDFdKTtcblxuICAgIC8vIFRoaXMgZWZmZWN0IGhhbmRsZXMgYXNzaWduaW5nIHRoZSBibG9ja2VyRnVuY3Rpb24uICBUaGlzIGlzIHRvIGhhbmRsZVxuICAgIC8vIHVuc3RhYmxlIGJsb2NrZXIgZnVuY3Rpb24gaWRlbnRpdGllcywgYW5kIGhhcHBlbnMgb25seSBhZnRlciB0aGUgcHJpb3JcbiAgICAvLyBlZmZlY3Qgc28gd2UgZG9uJ3QgZ2V0IGFuIG9ycGhhbmVkIGJsb2NrZXJGdW5jdGlvbiBpbiB0aGUgcm91dGVyIHdpdGggYVxuICAgIC8vIGtleSBvZiBcIlwiLiAgVW50aWwgdGhlbiB3ZSBqdXN0IGhhdmUgdGhlIElETEVfQkxPQ0tFUi5cbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgICByb3V0ZXIkMS5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfSwgW3JvdXRlciQxLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcblxuICAgIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XG4gICAgLy8gaXMgbWVtb2l6ZWQgc28gdGhpcyBlbnN1cmVzIHdlIHVwZGF0ZSBvbiBibG9ja2VyIHN0YXRlIHVwZGF0ZXNcbiAgICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiByb3V0ZXIuSURMRV9CTE9DS0VSO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YWJsZSB2ZXJzaW9uIG9mIHVzZU5hdmlnYXRlIHRoYXQgaXMgdXNlZCB3aGVuIHdlIGFyZSBpbiB0aGUgY29udGV4dCBvZlxuICAgKiBhIFJvdXRlclByb3ZpZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdXNlTmF2aWdhdGVTdGFibGUoKSB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlcjogcm91dGVyJDFcbiAgICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICAgIGxldCBpZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICAgIGxldCBhY3RpdmVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihmYWxzZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgbGV0IG5hdmlnYXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgcm91dGVyIHN1YnNjcmliZXIgeWV0XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJvdXRlciQxLm5hdmlnYXRlKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlciQxLm5hdmlnYXRlKHRvLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgZnJvbVJvdXRlSWQ6IGlkXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9LCBbcm91dGVyJDEsIGlkXSk7XG4gICAgcmV0dXJuIG5hdmlnYXRlO1xuICB9XG4gIGNvbnN0IGFscmVhZHlXYXJuZWQgPSB7fTtcbiAgZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5LCBjb25kLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAgICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gICAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICAgIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gICAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gICAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuICAqL1xuICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0X19uYW1lc3BhY2VbU1RBUlRfVFJBTlNJVElPTl07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gICAqL1xuICBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICAgIHJvdXRlcixcbiAgICAgIGZ1dHVyZVxuICAgIH0gPSBfcmVmO1xuICAgIC8vIE5lZWQgdG8gdXNlIGEgbGF5b3V0IGVmZmVjdCBoZXJlIHNvIHdlIGFyZSBzdWJzY3JpYmVkIGVhcmx5IGVub3VnaCB0b1xuICAgIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICAgIGxldCB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgICB9ID0gZnV0dXJlIHx8IHt9O1xuICAgIGxldCBzZXRTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgICBsZXQgbmF2aWdhdG9yID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LCBbcm91dGVyXSk7XG4gICAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICAgIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcm91dGVyLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgIGJhc2VuYW1lXG4gICAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcblxuICAgIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAgIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHN0YXRlXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3JcbiAgICB9LCBzdGF0ZS5pbml0aWFsaXplZCA/IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgICAgc3RhdGU6IHN0YXRlXG4gICAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVzLFxuICAgICAgc3RhdGVcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogQSA8Um91dGVyPiB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVyLWNvbXBvbmVudHMvbWVtb3J5LXJvdXRlclxuICAgKi9cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIGZ1dHVyZVxuICAgIH0gPSBfcmVmMztcbiAgICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSByb3V0ZXIuY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gICAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gICAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICAgKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gICAqL1xuICBmdW5jdGlvbiBOYXZpZ2F0ZShfcmVmNCkge1xuICAgIGxldCB7XG4gICAgICB0byxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHJlbGF0aXZlXG4gICAgfSA9IF9yZWY0O1xuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgXCI8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpICA6IHZvaWQgMDtcbiAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcoIVJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDtcbiAgICBsZXQge1xuICAgICAgbWF0Y2hlc1xuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuXG4gICAgLy8gUmVzb2x2ZSB0aGUgcGF0aCBvdXRzaWRlIG9mIHRoZSBlZmZlY3Qgc28gdGhhdCB3aGVuIGVmZmVjdHMgcnVuIHR3aWNlIGluXG4gICAgLy8gU3RyaWN0TW9kZSB0aGV5IG5hdmlnYXRlIHRvIHRoZSBzYW1lIHBsYWNlXG4gICAgbGV0IHBhdGggPSByb3V0ZXIucmVzb2x2ZVRvKHRvLCByb3V0ZXIuVU5TQUZFX2dldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpLm1hcChtYXRjaCA9PiBtYXRjaC5wYXRobmFtZUJhc2UpLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpO1xuICAgIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IG5hdmlnYXRlKEpTT04ucGFyc2UoanNvblBhdGgpLCB7XG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICByZWxhdGl2ZVxuICAgIH0pLCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZSwgc3RhdGVdKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9vdXRsZXRcbiAgICovXG4gIGZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICAgIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAgICovXG4gIGZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICAgIHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgXCIgKyBcIm5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5cIikgIDtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAgICpcbiAgICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgPFJvdXRlcj4gZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICAgKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIDxCcm93c2VyUm91dGVyPlxuICAgKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9yb3V0ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFJvdXRlcihfcmVmNSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgICBjaGlsZHJlbiA9IG51bGwsXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICAgICAgbmF2aWdhdGlvblR5cGUgPSByb3V0ZXIuQWN0aW9uLlBvcCxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG4gICAgfSA9IF9yZWY1O1xuICAgICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LlwiICsgXCIgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuXCIpICA6IHZvaWQgMDtcblxuICAgIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxuICAgIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxuICAgIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBzdGF0aWNQcm9wXG4gICAgfSksIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxvY2F0aW9uUHJvcCA9IHJvdXRlci5wYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCIsXG4gICAgICBzdGF0ZSA9IG51bGwsXG4gICAgICBrZXkgPSBcImRlZmF1bHRcIlxuICAgIH0gPSBsb2NhdGlvblByb3A7XG4gICAgbGV0IGxvY2F0aW9uQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiB7XG4gICAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHJvdXRlci5zdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgICBzZWFyY2gsXG4gICAgICAgICAgaGFzaCxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBrZXlcbiAgICAgICAgfSxcbiAgICAgICAgbmF2aWdhdGlvblR5cGVcbiAgICAgIH07XG4gICAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhsb2NhdGlvbkNvbnRleHQgIT0gbnVsbCwgXCI8Um91dGVyIGJhc2VuYW1lPVxcXCJcIiArIGJhc2VuYW1lICsgXCJcXFwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIFwiICsgKFwiXFxcIlwiICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoICsgXCJcXFwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgXCIpICsgXCJiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5cIikgO1xuICAgIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgdmFsdWU6IGxvY2F0aW9uQ29udGV4dFxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgPFJvdXRlPiBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICAgKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL3JvdXRlc1xuICAgKi9cbiAgZnVuY3Rpb24gUm91dGVzKF9yZWY2KSB7XG4gICAgbGV0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb25cbiAgICB9ID0gX3JlZjY7XG4gICAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBvbmVudCB0byB1c2UgZm9yIHJlbmRlcmluZyBsYXppbHkgbG9hZGVkIGRhdGEgZnJvbSByZXR1cm5pbmcgZGVmZXIoKVxuICAgKiBpbiBhIGxvYWRlciBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gQXdhaXQoX3JlZjcpIHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBlcnJvckVsZW1lbnQsXG4gICAgICByZXNvbHZlXG4gICAgfSA9IF9yZWY3O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwge1xuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIGVycm9yRWxlbWVudDogZXJyb3JFbGVtZW50XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZXNvbHZlQXdhaXQsIG51bGwsIGNoaWxkcmVuKSk7XG4gIH1cbiAgdmFyIEF3YWl0UmVuZGVyU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChBd2FpdFJlbmRlclN0YXR1cykge1xuICAgIEF3YWl0UmVuZGVyU3RhdHVzW0F3YWl0UmVuZGVyU3RhdHVzW1wicGVuZGluZ1wiXSA9IDBdID0gXCJwZW5kaW5nXCI7XG4gICAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJzdWNjZXNzXCJdID0gMV0gPSBcInN1Y2Nlc3NcIjtcbiAgICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcImVycm9yXCJdID0gMl0gPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIEF3YWl0UmVuZGVyU3RhdHVzO1xuICB9KEF3YWl0UmVuZGVyU3RhdHVzIHx8IHt9KTtcbiAgY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgY2xhc3MgQXdhaXRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3RfX25hbWVzcGFjZS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBlcnJvckVsZW1lbnQsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgICAgbGV0IHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgLy8gRGlkbid0IGdldCBhIHByb21pc2UgLSBwcm92aWRlIGFzIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzO1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHJlc29sdmVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgLy8gQ2F1Z2h0IGEgcmVuZGVyIGVycm9yLCBwcm92aWRlIGl0IGFzIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcjtcbiAgICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge30pOyAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcm5pbmdzXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiByZW5kZXJFcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZS5fdHJhY2tlZCkge1xuICAgICAgICAvLyBBbHJlYWR5IHRyYWNrZWQgcHJvbWlzZSAtIGNoZWNrIGNvbnRlbnRzXG4gICAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICBzdGF0dXMgPSBwcm9taXNlLl9lcnJvciAhPT0gdW5kZWZpbmVkID8gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgOiBwcm9taXNlLl9kYXRhICE9PSB1bmRlZmluZWQgPyBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihkYXRhID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9kYXRhXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICAgICAgfSksIGVycm9yID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiBwcm9taXNlLl9lcnJvciBpbnN0YW5jZW9mIHJvdXRlci5BYm9ydGVkRGVmZXJyZWRFcnJvcikge1xuICAgICAgICAvLyBGcmVlemUgdGhlIFVJIGJ5IHRocm93aW5nIGEgbmV2ZXIgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgICB0aHJvdyBuZXZlclNldHRsZWRQcm9taXNlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgIHRocm93IHByb21pc2UuX2Vycm9yO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgICAgLy8gUmVuZGVyIHZpYSBvdXIgZXJyb3JFbGVtZW50XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBlcnJvckVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzKSB7XG4gICAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhyb3cgdG8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBJbmRpcmVjdGlvbiB0byBsZXZlcmFnZSB1c2VBc3luY1ZhbHVlIGZvciBhIHJlbmRlci1wcm9wIEFQSSBvbiA8QXdhaXQ+XG4gICAqL1xuICBmdW5jdGlvbiBSZXNvbHZlQXdhaXQoX3JlZjgpIHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjg7XG4gICAgbGV0IGRhdGEgPSB1c2VBc3luY1ZhbHVlKCk7XG4gICAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhKSA6IGNoaWxkcmVuO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIHRvUmVuZGVyKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gVVRJTFNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcm91dGUgY29uZmlnIGZyb20gYSBSZWFjdCBcImNoaWxkcmVuXCIgb2JqZWN0LCB3aGljaCBpcyB1c3VhbGx5XG4gICAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICAgKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9jcmVhdGUtcm91dGVzLWZyb20tY2hpbGRyZW5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50UGF0aCkge1xuICAgIGlmIChwYXJlbnRQYXRoID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmVudFBhdGggPSBbXTtcbiAgICB9XG4gICAgbGV0IHJvdXRlcyA9IFtdO1xuICAgIFJlYWN0X19uYW1lc3BhY2UuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoISAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXG4gICAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50KSB7XG4gICAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAhKGVsZW1lbnQudHlwZSA9PT0gUm91dGUpID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiW1wiICsgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZSkgKyBcIl0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PlwiKSAgOiB2b2lkIDA7XG4gICAgICAhKCFlbGVtZW50LnByb3BzLmluZGV4IHx8ICFlbGVtZW50LnByb3BzLmNoaWxkcmVuKSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIikgIDogdm9pZCAwO1xuICAgICAgbGV0IHJvdXRlID0ge1xuICAgICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICAgIGFjdGlvbjogZWxlbWVudC5wcm9wcy5hY3Rpb24sXG4gICAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQgIT0gbnVsbCxcbiAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgICBsYXp5OiBlbGVtZW50LnByb3BzLmxhenlcbiAgICAgIH07XG4gICAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCk7XG4gICAgICB9XG4gICAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvdXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XG4gICAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gICAgbGV0IHVwZGF0ZXMgPSB7XG4gICAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCByb3V0ZS5lcnJvckVsZW1lbnQgIT0gbnVsbFxuICAgIH07XG4gICAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgICAge1xuICAgICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYENvbXBvbmVudGAgYW5kIGBlbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIikgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgICBDb21wb25lbnQ6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgICB7XG4gICAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiKSA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgICBlcnJvckVsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICAgIEVycm9yQm91bmRhcnk6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgICByZXR1cm4gcm91dGVyLmNyZWF0ZVJvdXRlcih7XG4gICAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgICAgfSksXG4gICAgICBoaXN0b3J5OiByb3V0ZXIuY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgICBpbml0aWFsSW5kZXg6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEluZGV4XG4gICAgICB9KSxcbiAgICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSxcbiAgICAgIHJvdXRlcyxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICAgIH0pLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQWJvcnRlZERlZmVycmVkRXJyb3InLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5BYm9ydGVkRGVmZXJyZWRFcnJvcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOYXZpZ2F0aW9uVHlwZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLkFjdGlvbjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuY3JlYXRlUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLmRlZmVyOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dlbmVyYXRlUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLmdlbmVyYXRlUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc1JvdXRlRXJyb3JSZXNwb25zZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLmlzUm91dGVFcnJvclJlc3BvbnNlOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2pzb24nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5qc29uOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ21hdGNoUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLm1hdGNoUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdtYXRjaFJvdXRlcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLm1hdGNoUm91dGVzOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3BhcnNlUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnBhcnNlUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZWRpcmVjdCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnJlZGlyZWN0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlZGlyZWN0RG9jdW1lbnQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5yZWRpcmVjdERvY3VtZW50OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3Jlc29sdmVQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIucmVzb2x2ZVBhdGg7IH1cbiAgfSk7XG4gIGV4cG9ydHMuQXdhaXQgPSBBd2FpdDtcbiAgZXhwb3J0cy5NZW1vcnlSb3V0ZXIgPSBNZW1vcnlSb3V0ZXI7XG4gIGV4cG9ydHMuTmF2aWdhdGUgPSBOYXZpZ2F0ZTtcbiAgZXhwb3J0cy5PdXRsZXQgPSBPdXRsZXQ7XG4gIGV4cG9ydHMuUm91dGUgPSBSb3V0ZTtcbiAgZXhwb3J0cy5Sb3V0ZXIgPSBSb3V0ZXI7XG4gIGV4cG9ydHMuUm91dGVyUHJvdmlkZXIgPSBSb3V0ZXJQcm92aWRlcjtcbiAgZXhwb3J0cy5Sb3V0ZXMgPSBSb3V0ZXM7XG4gIGV4cG9ydHMuVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0ID0gRGF0YVJvdXRlckNvbnRleHQ7XG4gIGV4cG9ydHMuVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBEYXRhUm91dGVyU3RhdGVDb250ZXh0O1xuICBleHBvcnRzLlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQgPSBMb2NhdGlvbkNvbnRleHQ7XG4gIGV4cG9ydHMuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0ID0gTmF2aWdhdGlvbkNvbnRleHQ7XG4gIGV4cG9ydHMuVU5TQUZFX1JvdXRlQ29udGV4dCA9IFJvdXRlQ29udGV4dDtcbiAgZXhwb3J0cy5VTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzID0gbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBleHBvcnRzLlVOU0FGRV91c2VSb3V0ZUlkID0gdXNlUm91dGVJZDtcbiAgZXhwb3J0cy5VTlNBRkVfdXNlUm91dGVzSW1wbCA9IHVzZVJvdXRlc0ltcGw7XG4gIGV4cG9ydHMuY3JlYXRlTWVtb3J5Um91dGVyID0gY3JlYXRlTWVtb3J5Um91dGVyO1xuICBleHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbiAgZXhwb3J0cy5jcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMgPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW47XG4gIGV4cG9ydHMucmVuZGVyTWF0Y2hlcyA9IHJlbmRlck1hdGNoZXM7XG4gIGV4cG9ydHMudW5zdGFibGVfdXNlQmxvY2tlciA9IHVzZUJsb2NrZXI7XG4gIGV4cG9ydHMudXNlQWN0aW9uRGF0YSA9IHVzZUFjdGlvbkRhdGE7XG4gIGV4cG9ydHMudXNlQXN5bmNFcnJvciA9IHVzZUFzeW5jRXJyb3I7XG4gIGV4cG9ydHMudXNlQXN5bmNWYWx1ZSA9IHVzZUFzeW5jVmFsdWU7XG4gIGV4cG9ydHMudXNlSHJlZiA9IHVzZUhyZWY7XG4gIGV4cG9ydHMudXNlSW5Sb3V0ZXJDb250ZXh0ID0gdXNlSW5Sb3V0ZXJDb250ZXh0O1xuICBleHBvcnRzLnVzZUxvYWRlckRhdGEgPSB1c2VMb2FkZXJEYXRhO1xuICBleHBvcnRzLnVzZUxvY2F0aW9uID0gdXNlTG9jYXRpb247XG4gIGV4cG9ydHMudXNlTWF0Y2ggPSB1c2VNYXRjaDtcbiAgZXhwb3J0cy51c2VNYXRjaGVzID0gdXNlTWF0Y2hlcztcbiAgZXhwb3J0cy51c2VOYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlO1xuICBleHBvcnRzLnVzZU5hdmlnYXRpb24gPSB1c2VOYXZpZ2F0aW9uO1xuICBleHBvcnRzLnVzZU5hdmlnYXRpb25UeXBlID0gdXNlTmF2aWdhdGlvblR5cGU7XG4gIGV4cG9ydHMudXNlT3V0bGV0ID0gdXNlT3V0bGV0O1xuICBleHBvcnRzLnVzZU91dGxldENvbnRleHQgPSB1c2VPdXRsZXRDb250ZXh0O1xuICBleHBvcnRzLnVzZVBhcmFtcyA9IHVzZVBhcmFtcztcbiAgZXhwb3J0cy51c2VSZXNvbHZlZFBhdGggPSB1c2VSZXNvbHZlZFBhdGg7XG4gIGV4cG9ydHMudXNlUmV2YWxpZGF0b3IgPSB1c2VSZXZhbGlkYXRvcjtcbiAgZXhwb3J0cy51c2VSb3V0ZUVycm9yID0gdXNlUm91dGVFcnJvcjtcbiAgZXhwb3J0cy51c2VSb3V0ZUxvYWRlckRhdGEgPSB1c2VSb3V0ZUxvYWRlckRhdGE7XG4gIGV4cG9ydHMudXNlUm91dGVzID0gdXNlUm91dGVzO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJvdXRlci5kZXZlbG9wbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/umd/react-router.development.js\n");

/***/ })

};
;